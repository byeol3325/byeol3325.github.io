---
title:  "[Computer Vision] ISS(Intrinsic Shape Signatures)μ— λ€ν•μ—¬" 
categories: studying
tag: [python, studying, 3D, point cloud, computer vision, cv]
date: 2024-07-25
toc: true
use_math: true
sidebar:
    nav: "docs"
last_modified_at: 2024-08-06
---

3D ν¬μΈνΈ ν΄λΌμ°λ“ μ²λ¦¬ λ¶„μ•Όμ—μ„ ν‚¤ν¬μΈνΈλ¥Ό μ‹λ³„ν•λ” κ²ƒμ€ κ°μ²΄ μΈμ‹, μ •ν•©, μ¥λ©΄ μ΄ν•΄ λ“± λ‹¤μ–‘ν• μ‘μ© λ¶„μ•Όμ—μ„ μ¤‘μ”ν•©λ‹λ‹¤. 3D ν¬μΈνΈ ν΄λΌμ°λ“μ—μ„ ν‚¤ν¬μΈνΈλ¥Ό κ°μ§€ν•λ” λ° μ‚¬μ©λλ” λ°©λ²• μ¤‘ ν•λ‚μΈ Intrinsic Shape Signatures (ISS) μ•κ³ λ¦¬μ¦μ΄ λ¬΄μ—‡μΈμ§€ κ°„λ‹¨ν•κ² μ„¤λ…ν•κ³ , Computer Visionμ™€ AIμ—μ„ μ–Έμ  μ–΄λ–»κ² μ“°μ΄λ”μ§€ μμ‹μ™€ ν•¨κ» λ‹¤λ£° μμ •μ…λ‹λ‹¤. (λ³ΈμΈ κ³µλ¶€ λ° κΈ°λ΅μ©)π

# ISS(Intrinsic Shape Signatures)λ€?
**ISS(Intrinsic Shape Signatures)**λ” **3D ν¬μΈνΈ ν΄λΌμ°λ“ λ°μ΄ν„°μ—μ„ μ¤‘μ”ν• ν¬μΈνΈ(ν‚¤ν¬μΈνΈ)λ¥Ό κ²€μ¶ν•κΈ° μ„ν• μ•κ³ λ¦¬μ¦μ…**λ‹λ‹¤. μ΄ μ•κ³ λ¦¬μ¦μ€ **ν¬μΈνΈ ν΄λΌμ°λ“μ κ° ν¬μΈνΈ μ£Όλ³€μ ν•μƒμ„ λ¶„μ„ν•μ—¬, ν•΄λ‹Ή ν¬μΈνΈκ°€ μ¤‘μ”ν•μ§€ μ•„λ‹μ§€λ¥Ό νλ‹¨**ν•©λ‹λ‹¤. μ‰½κ² λ§ν•΄μ„, ISSλ” 3D λ°μ΄ν„°μ—μ„ νΉλ³„ν• ν¬μΈνΈλ“¤μ„ μ°Ύλ” λ° μ‚¬μ©λ©λ‹λ‹¤.
Yu Zhong , β€Intrinsic Shape Signatures: A Shape Descriptor for 3D Object Recognitionβ€, 2009 μ—μ„ μ²μ μ μ•λμµλ‹λ‹¤.

[OpenCV ISS](https://www.open3d.org/docs/latest/tutorial/Advanced/iss_keypoint_detector.html) μ°Έκ³ 

# ISS ν‚¤ν¬μΈνΈ κ²€μ¶ μ›λ¦¬
ISS ν‚¤ν¬μΈνΈ κ²€μ¶μ€ ν¬μΈνΈ **μ£Όλ³€μ μ  λ¶„ν¬λ¥Ό λ¶„μ„ν•μ—¬ μ¤‘μ”ν• ν¬μΈνΈλ¥Ό** μ°Ύμµλ‹λ‹¤. μ΄λ¥Ό μ„ν•΄ μ£Όλ΅ **κ³ μ κ°’ λ¶„ν•΄(Eigenvalue Decomposition, EVD)λ¥Ό μ‚¬μ©**ν•©λ‹λ‹¤. λ‹¤μμ€ ISSμ μ£Όμ” λ‹¨κ³„λ“¤μ…λ‹λ‹¤.


## 1. ν¬μΈνΈ μ£Όλ³€ μμ—­ μ„¤μ •
κ° ν¬μΈνΈ **$P_i$μ— λ€ν•΄ λ°κ²½ rμ„ μ„¤μ •ν•μ—¬ μ΄ λ°κ²½ λ‚΄μ μ΄μ›ƒ ν¬μΈνΈλ“¤μ„** κµ¬ν•©λ‹λ‹¤. μ΄μ›ƒ ν¬μΈνΈ μ§‘ν•©μ„ $N_i$λΌ ν•©λ‹λ‹¤.


## 2. κ³µλ¶„μ‚° ν–‰λ ¬ κ³„μ‚°
ν¬μΈνΈ $P_i$μ μ΄μ›ƒ ν¬μΈνΈ μ§‘ν•© $N_i$μ— λ€ν• κ³µλ¶„μ‚° ν–‰λ ¬μ„ κ³„μ‚°ν•©λ‹λ‹¤. κ³µλ¶„μ‚° ν–‰λ ¬ Cλ” λ‹¤μκ³Ό κ°™μ΄ μ •μλ©λ‹λ‹¤.
<p align="center">
$
C = \frac{1}{|N_i|}\sum_{P_j \in N_i}(P_j - \mu _i)(P_j - \mu _i)^T
$
</p>
μ—¬κΈ°μ„ $\mu _i$λ” μ΄μ›ƒ ν¬μΈνΈλ“¤μ ν‰κ· μ…λ‹λ‹¤.

## 3. κ³ μ κ°’ λ¶„ν•΄
κ³µλ¶„μ‚° ν–‰λ ¬ Cλ¥Ό κ³ μ κ°’ λ¶„ν•΄ν•μ—¬ κ³ μ κ°’κ³Ό κ³ μ λ²΅ν„°λ¥Ό μ–»μµλ‹λ‹¤. κ³ μ κ°’μ€ $ \lambda _1 \lambda _2 \lambda _3$λ΅ μ •λ ¬λ©λ‹λ‹¤. 

λ‹¨, $ \lambda _1 \leq \lambda _2 \leq \lambda _3 $

## 4. κ³ μ κ°’ λΉ„μ¨ κ³„μ‚°
κ³ μ κ°’ λΉ„μ¨μ„ μ‚¬μ©ν•μ—¬ keypoint μ—¬λ¶€λ¥Ό κ²°μ •ν•©λ‹λ‹¤.
<p align="center">
$
\frac{\lambda _2}{\lambda _3} : λ‚®μ€ κ°’μ€ ν‰ν‰ν• μμ—­μ„ λ‚νƒ€λƒ…λ‹λ‹¤ \\
\frac{\lambda _1}{\lambda _2} : λ‚®μ€ κ°’μ€ μ„ ν• κµ¬μ΅°λ¥Ό λ‚νƒ€λƒ…λ‹λ‹¤.
$
</p>
μ΄ λΉ„μ¨μ΄ **μΌμ • μ„κ³„κ°’μ„ μ΄κ³Όν•λ©΄ ν•΄λ‹Ή ν¬μΈνΈλ¥Ό keypointλ΅** κ°„μ£Όν•©λ‹λ‹¤.

## 5. λΉ„μµμ† μ–µμ 
keypointλ΅ μ„ νƒλ ν¬μΈνΈλ“¤ μ¤‘μ—μ„ λ” μ¤‘μ”ν• ν¬μΈνΈλ¥Ό μ„ νƒν•κΈ° μ„ν•΄μ„ **λΉ„μµμ† μ–µμ (Non-Maximum Suppression)**λ¥Ό μ μ©ν•©λ‹λ‹¤. μ΄λ” **μ£Όλ³€ ν¬μΈνΈμ™€ λΉ„κµν•μ—¬ κ³ μ κ°’μ΄ μµλ€μΈ ν¬μΈνΈλ§μ„ μ„ νƒ**ν•λ” κ³Όμ •μ…λ‹λ‹¤.

# ISS μ¥μ  κ³Ό λ‹¨μ 
**+κ°•λ ¥ν• νΉμ§•μ  κ²€μ¶**: 3D ν¬μΈνΈ ν΄λΌμ°λ“ λ°μ΄ν„°μ—μ„ κ°•λ ¥ν•κ³  μ•μ •μ μΈ νΉμ§• ν¬μΈνΈλ¥Ό κ²€μ¶ν•  μ μμµλ‹λ‹¤.
**+νμ „ λ¶λ³€μ„±**: ν¬μΈνΈ ν΄λΌμ°λ“ νμ „μ— λ€ν•΄ λ¶λ³€μ„±μ„ κ°€μ§‘λ‹λ‹¤.
**+κ°„λ‹¨ν• κ³„μ‚°**: κ³µλ¶„μ‚° ν–‰λ ¬ κ³„μ‚°κ³Ό κ³ μ κ°’ λ¶„ν•΄λ¥Ό μ‚¬μ©ν•μ—¬ λΉ„κµμ  κ°„λ‹¨ν•κ² νΉμ§• ν¬μΈνΈλ¥Ό κ²€μ¶ν•©λ‹λ‹¤.

**-λ°€λ„ μμ΅΄μ„±**: ν¬μΈνΈ ν΄λΌμ°λ“μ λ°€λ„κ°€ λ¶κ· μΌν•  κ²½μ° μ„±λ¥μ΄ μ €ν•λ  μ μμµλ‹λ‹¤.
**-λ…Έμ΄μ¦ λ―Όκ°μ„±**: λ…Έμ΄μ¦μ— λ―Όκ°ν•μ—¬ μ •ν™•ν• ν‚¤ν¬μΈνΈ κ²€μ¶μ΄ μ–΄λ ¤μΈ μ μμµλ‹λ‹¤.

```python
import numpy as np
from sklearn.neighbors import NearestNeighbors

def compute_covariance_matrix(points):
    """
    κ³µλ¶„μ‚° ν–‰λ ¬ κ³„μ‚°

    params points (np.array): ν¬μΈνΈλ“¤μ λ°°μ—΄ (N x 3)

    Returns np.array: μ£Όμ–΄μ§„ ν¬μΈνΈλ“¤μ κ³µλ¶„μ‚° ν–‰λ ¬ (3 x 3)
    """
    mean = np.mean(points, axis=0) # κ° μ¶•μ— λ€ν• ν‰κ·  κ³„μ‚°
    centered_points = points - mean # ν‰κ· μ„ λΊ€ μ¤‘μ‹¬ν™”λ ν¬μΈνΈλ“¤
    covariance_matrix = np.dot(centered_points.T, centered_points) / len(points) # κ³µλ¶„μ‚° ν–‰λ ¬ κ³„μ‚°
    return covariance_matrix

def iss_keypoints(points, radius, gamma21, gamma32):
    """
    ISS ν‚¤ν¬μΈνΈλ“¤μ„ μ¶”μ¶ν•©λ‹λ‹¤.
    
    params points (np.array): ν¬μΈνΈλ“¤μ λ°°μ—΄ (N x 3)
    params radius (float): μ΄μ›ƒ ν¬μΈνΈλ¥Ό μ°ΎκΈ° μ„ν• λ°κ²½
    params gamma21 (float): λ‘ λ²μ§Έ κ³ μ κ°’κ³Ό μ„Έ λ²μ§Έ κ³ μ κ°’μ λΉ„μ¨μ— λ€ν• μ„κ³„κ°’
    params gamma32 (float): μ²« λ²μ§Έ κ³ μ κ°’κ³Ό λ‘ λ²μ§Έ κ³ μ κ°’μ λΉ„μ¨μ— λ€ν• μ„κ³„κ°’
    
    Returns np.array: κ²€μ¶λ ISS ν‚¤ν¬μΈνΈλ“¤μ λ°°μ—΄
    """
    keypoints = [] # ν‚¤ν¬μΈνΈλ“¤μ„ μ €μ¥ν•  λ¦¬μ¤νΈ
    neighbors = NearestNeighbors(radius=radius) # radius μ΄λ‚΄ μ΄μ›ƒν¬μΈνΈλ“¤ κ²€μ¶
    neighbors.fit(points) # ν¬μΈνΈλ“¤λ΅ NearestNeighbors κ°μ²΄λ¥Ό ν›λ ¨μ‹ν‚΄
    
    for point in points:
        indices = neighbors.radius_neighbors([point], return_distance=False)[0] # λ°κ²½ μ΄λ‚΄μ μ΄μ›ƒ ν¬μΈνΈ μΈλ±μ¤
        if len(indices) < 3: # μ΄μ›ƒ ν¬μΈνΈκ°€ 3κ° λ―Έλ§μ΄λ©΄ κ±΄λ„λ€
            continue
        
        neighborhood = points[indices]
        covariance_matrix = compute_covariance_matrix(neighborhood) # μ΄μ›ƒ ν¬μΈνΈλ“¤μ κ³µλ¶„μ‚° ν–‰λ ¬ κ³„μ‚°
        eigenvalues, _ = np.linalg.eigh(covariance_matrix) # κ³µλ¶„μ‚° ν–‰λ ¬μ κ³ μ κ°’ κ³„μ‚°
        eigenvalues = np.sort(eigenvalues) # κ³ μ κ°’μ„ μ¤λ¦„μ°¨μμΌλ΅ μ •λ ¬
        
        # κ³ μ κ°’ λΉ„μ¨μ„ μ‚¬μ©ν•μ—¬ ν‚¤ν¬μΈνΈ μ—¬λ¶€ κ²°μ •
        if eigenvalues[1] / eigenvalues[2] < gamma21 and eigenvalues[0] / eigenvalues[1] < gamma32:
            keypoints.append(point) # μ΅°κ±΄μ„ λ§μ΅±ν•λ©΄ ν‚¤ν¬μΈνΈλ΅ μ¶”κ°€
    
    return np.array(keypoints) # ν‚¤ν¬μΈνΈλ“¤μ„ λ°°μ—΄λ΅ λ°ν™

# μμ  ν¬μΈνΈ ν΄λΌμ°λ“ λ°μ΄ν„°
points = np.random.rand(1000, 3)

# ISS νλΌλ―Έν„°
radius = 0.05
gamma21 = 0.8
gamma32 = 0.8

keypoints = iss_keypoints(points, radius, gamma21, gamma32)
```

μ΄κ²ƒμ €κ²ƒ κ³µλ¶€ν•λ©΄μ„ ISS κΈ°λ²•μ— λ€ν•΄ μƒλ΅ μ•κ² λλ” λ‚΄μ©μ€ κ³„μ† μ¶”κ°€ν•  μμ •μ…λ‹λ‹¤. κ¶κΈν• κ²ƒλ“¤μ΄λ‚ μ¶”κ°€ λ° μμ •ν–μΌλ©΄ μΆ‹κ² λ” κ±° λ§ν•΄μ£Όμ‹λ©΄ μΆ‹μ„ κ±° κ°™μ•„μ”.
μΆ‹μ€ ν•λ£¨ λ³΄λ‚΄μ‹κΈΈ λ°”λμ” :)